#version 450
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct VoxelData
{
    vec2 x_range;
    vec2 y_range;
    vec2 z_range;
    vec2 color_rg;
    vec2 color_ba;
    uint _0_0_index;
    uint _0_1_index;
    uint _0_2_index;
    uint _0_3_index;
    uint _1_0_index;
    uint _1_1_index;
    uint _1_2_index;
    uint _1_3_index;
};

layout(set = 0, binding = 0) readonly buffer Data {
    VoxelData data[];
} voxel_data;

layout(set = 0, binding = 1)  readonly buffer RawCameraData {
    uint field_of_view;
    float render_distance;
    float aspectRatio;
    float fov_tan;
    mat4 raw_camera_to_world;
    vec4 clear_color;
} rawCameraData;

layout(set = 1, binding = 0, rgba8) uniform image2D img_out; 

struct ColorHit {
    bool hit;
    vec4 color;
};

struct Camera {
    uint field_of_view;
    float render_distance;
    float aspectRatio;
    float fov_tan;
    mat4 camera_to_world;
    vec4 clear_color;
};

// Const variables
vec3 lookingDir = vec3(0.0, 0.0, 1.0);
vec3 currentPos = vec3(0.0, 0.0, 0.0);
            
// Helper functions
ColorHit voxel_hit(ivec3 pos, vec4 clear_col) {
    ColorHit ret_val;
    ret_val.hit = false;

    uint index = voxel_data.data.length()-1;
    uint counter = 0;
    uint max_count = 20;
    while (counter < max_count && !ret_val.hit) {
        counter += 1;

        VoxelData current_voxel = voxel_data.data[index];
        ret_val.color = vec4(current_voxel.color_rg, current_voxel.color_ba);

        if (!(current_voxel.x_range.x <= pos.x && pos.x <= current_voxel.x_range.y &&
            current_voxel.y_range.x <= pos.y && pos.y <= current_voxel.y_range.y &&
            current_voxel.z_range.x <= pos.z && pos.z <= current_voxel.z_range.y)) {
            break;
        }

        if (current_voxel._0_0_index == uint(-1) && current_voxel._0_1_index == uint(-1) &&
            current_voxel._0_2_index == uint(-1) && current_voxel._0_3_index == uint(-1) &&
            current_voxel._1_0_index == uint(-1) && current_voxel._1_1_index == uint(-1) &&
            current_voxel._1_2_index == uint(-1) && current_voxel._1_3_index == uint(-1)) {
                ret_val.hit = true;
                break;
        }

        bool x_small = false;
        bool y_small = false;
        bool z_small = false;
    
        if (pos.x < (current_voxel.x_range.x + current_voxel.x_range.y)/2) x_small = true;
        if (pos.y < (current_voxel.y_range.x + current_voxel.y_range.y)/2) y_small = true;
        if (pos.z < (current_voxel.z_range.x + current_voxel.z_range.y)/2) z_small = true;

        if (x_small && y_small && z_small) {
            if (current_voxel._0_0_index != uint(-1)) index = current_voxel._0_0_index;
            else break;
        } else if (!x_small && y_small && z_small) {
            if (current_voxel._0_1_index != uint(-1)) index = current_voxel._0_1_index;
            else break;
        } else if (x_small && y_small && !z_small) {
            if (current_voxel._0_2_index != uint(-1)) index = current_voxel._0_2_index;
            else break;
        } else if (!x_small && y_small && !z_small) {
            if (current_voxel._0_3_index != uint(-1)) index = current_voxel._0_3_index;
            else break;
        } else if (x_small && !y_small && z_small) {
            if (current_voxel._1_0_index != uint(-1)) index = current_voxel._1_0_index;
            else break;
        } else if (!x_small && !y_small && z_small) {
            if (current_voxel._1_1_index != uint(-1)) index = current_voxel._1_1_index;
            else break;
        } else if (x_small && !y_small && !z_small) {
            if (current_voxel._1_2_index != uint(-1)) index = current_voxel._1_2_index;
            else break;
        } else if (!x_small && !y_small && !z_small) {
            if (current_voxel._1_3_index != uint(-1)) index = current_voxel._1_3_index;
            else break;
        } else {
            ret_val.hit = true;
            ret_val.color = vec4(0.75, 0.5, 0.25, 1.0);
        }

    }
    
    if (!ret_val.hit) ret_val.color = clear_col;

    return ret_val;
}

// Main         
void main() {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);

    Camera camera;
    camera.field_of_view = rawCameraData.field_of_view;
    camera.aspectRatio = rawCameraData.aspectRatio;
    camera.fov_tan = rawCameraData.fov_tan;
    camera.camera_to_world = rawCameraData.raw_camera_to_world;
    camera.clear_color = rawCameraData.clear_color;
    
    ivec2 screenSize = imageSize(img_out);
    vec2 pixel_NCD = vec2((float(IDxy.x)+0.5)/float(screenSize.x), (float(IDxy.y)+0.5)/float(screenSize.y));
    vec2 camera_pixel = vec2((2 * pixel_NCD.x - 1) * camera.aspectRatio * camera.fov_tan, (1 - 2 * pixel_NCD.y) * camera.fov_tan);

    highp vec4 world_search_pos = vec4(vec3(camera_pixel.x, camera_pixel.y, -1.0), 0.0)*camera.camera_to_world;
    highp vec3 current_search_pos = normalize(world_search_pos.xyz);
    current_search_pos.x = -current_search_pos.x;
    vec4 color_in_the_end = camera.clear_color;
    
    while (length(current_search_pos) < rawCameraData.render_distance) {
        ivec3 current_box = ivec3(floor(current_search_pos.x), floor(current_search_pos.y), floor(current_search_pos.z));
        ColorHit check = voxel_hit(current_box, camera.clear_color);
        if (check.hit) {
            color_in_the_end = check.color;
            break;
        }

        highp float multiplier = 999.0;
        highp float x_mul = ceil(current_search_pos.x)/current_search_pos.x + 0.001;
        highp float y_mul = ceil(current_search_pos.y)/current_search_pos.y + 0.001;
        highp float z_mul = ceil(current_search_pos.z)/current_search_pos.z + 0.001;
        if (x_mul < multiplier) multiplier = x_mul;
        if (y_mul < multiplier) multiplier = y_mul;
        if (z_mul < multiplier) multiplier = z_mul;
        if (multiplier <= 1.0) multiplier = 1.01;

        current_search_pos *= multiplier;
    }

    imageStore(img_out, IDxy, vec4(color_in_the_end.b, color_in_the_end.g, color_in_the_end.r, color_in_the_end.a));
}